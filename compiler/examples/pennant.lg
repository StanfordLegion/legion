/* Copyright 2013 Stanford University and Los Alamos National Security, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// run-with-params:
// [
//   ["pennant.tests/sedovsmall/sedovsmall.pnt", "-npieces", "1", "-foreign", "0"],
//   ["pennant.tests/sedovsmall/sedovsmall.pnt", "-npieces", "1", "-foreign", "1"],
//   ["pennant.tests/sedovsmall/sedovsmall.pnt", "-npieces", "2", "-foreign", "0"],
//   ["pennant.tests/sedovsmall/sedovsmall.pnt", "-npieces", "2", "-foreign", "1"],
//   ["pennant.tests/sedovsmall/sedovsmall.pnt", "-npieces", "4", "-foreign", "0"],
//   ["pennant.tests/sedovsmall/sedovsmall.pnt", "-npieces", "4", "-foreign", "1"],
//   ["pennant.tests/sedov/sedov.pnt", "-npieces", "1", "-foreign", "0"],
//   ["pennant.tests/sedov/sedov.pnt", "-npieces", "1", "-foreign", "1"],
//   ["pennant.tests/sedov/sedov.pnt", "-npieces", "2", "-foreign", "0"],
//   ["pennant.tests/sedov/sedov.pnt", "-npieces", "2", "-foreign", "1"],
//   ["pennant.tests/sedov/sedov.pnt", "-npieces", "4", "-foreign", "0"],
//   ["pennant.tests/sedov/sedov.pnt", "-npieces", "4", "-foreign", "1"]
// ]

// Inspired by https://github.com/losalamos/PENNANT

import "math.h";
import "pennant.h";

///
/// Data Structures
///

struct zone
{
  znump:  int,          // number of points in zone
  zxp:    vec2,         // zone center coordinates, middle of cycle
  zx:     vec2,         // zone center coordinates, end of cycle
  zareap: double,       // zone area, middle of cycle
  zarea:  double,       // zone area, end of cycle
  zvol0:  double,       // zone volume, start of cycle
  zvolp:  double,       // zone volume, middle of cycle
  zvol:   double,       // zone volume, end of cycle
  zdl:    double,       // zone characteristic length
  zm:     double,       // zone mass
  zrp:    double,       // zone density, middle of cycle
  zr:     double,       // zone density, end of cycle
  ze:     double,       // zone specific energy
  zetot:  double,       // zone total energy
  zw:     double,       // zone work
  zwrate: double,       // zone work rate
  zp:     double,       // zone pressure
  zss:    double,       // zone sound speed

  // Temporaries for QCS
  zuc:    vec2,         // zone center velocity
}

struct point
{
  px0: vec2,            // point coordinates, start of cycle
  pxp: vec2,            // point coordinates, middle of cycle
  px:  vec2,            // point coordinates, end of cycle
  pu0: vec2,            // point velocity, start of cycle
  pu:  vec2,            // point velocity, end of cycle
  pap: vec2,            // point acceleration, middle of cycle
  pf:  vec2,            // point force
  pmaswt: double,       // point mass

  // Used for computing boundary conditions
  has_bcx_0: bool,
  has_bcx_1: bool,
  has_bcy_0: bool,
  has_bcy_1: bool,
}

struct side<rz: region<zone>, rpp: region<point>, rpg: region<point>, rs: region<side<rz, rpp, rpg, rs>>>
{
  mapsz:  zone@rz,                      // maps: side -> zone
  mapsp1: point@(rpp, rpg),             // maps: side -> points 1 and 2
  mapsp2: point@(rpp, rpg),
  mapss3: side<rz, rpp, rpg, rs>@rs,    // maps: side -> previous side
  mapss4: side<rz, rpp, rpg, rs>@rs,    // maps: side -> next side

  sareap: double,       // side area, middle of cycle
  sarea:  double,       // side area, end of cycle
  svolp:  double,       // side volume, middle of cycle
  svol:   double,       // side volume, end of cycle
  ssurfp: vec2,         // side surface vector, middle of cycle
  smf:    double,       // side mass fraction
  sfp:    vec2,         // side force, pgas
  sft:    vec2,         // side force, tts
  sfq:    vec2,         // side force, qcs

  // In addition to storing their own state, sides also store the
  // state of edges and corners. This can be done because there is a
  // 1-1 correspondence between sides and edges/corners. Technically,
  // edges can be shared between zones, but the computations on edges
  // are minimal, and are not actually used for sharing information,
  // so duplicating computations on edges is inexpensive.

  // Edge variables
  exp:    vec2,         // edge center coordinates, middle of cycle
  ex:     vec2,         // edge center coordinates, end of cycle
  elen:   double,       // edge length, end of cycle

  // Corner variables (temporaries for QCS)
  carea:  double,       // corner area
  cevol:  double,       // corner evol
  cdu:    double,       // corner delta velocity
  cdiv:   double,       // ??????????
  ccos:   double,       // corner cosine
  cqe1:   vec2,         // ??????????
  cqe2:   vec2,         // ??????????
}

struct mesh<rz: region<zone>, rp: region<point>, rs: region<side<?, ?, ?, ?>>>
           [rzp: region<zone>, rpp: region<point>, rpg: region<point>, rps: region<point>, rsp: region<side<rzp, rpp, rpg, rsp>>]
  , rzp <= rz, rpp <= rp, rpg <= rp, rps <= rp, rpp * rpg, rpp * rps, rsp <= rs
{
  // Coloring
  mcolor: int,          // mesh piece color

  // Index bounds for C++ kernels
  zstart: int,          // zone start index
  zend: int,            // zone end index (exclusive)
  sstart: int,          // side start index
  send: int,            // side end index (exclusive)
}

///
/// Initialization
///

// Hack: This exists to make the compiler recompute the bitmasks for
// each pointer. This needs to happen here (rather than at
// initialization time) because we subverted the type system in the
// construction of the mesh pieces.
task init_pointers(rz: region<zone>, rpp: region<point>, rpg: region<point>,
                   rs: region<side<rz, rpp, rpg, rs>>)
  , reads(rs.{mapsp1, mapsp2})
  , writes(rs.{mapsp1, mapsp2})
{
  for s in rs {
    s->mapsp1 = downregion<rpp, rpg>(s->mapsp1);
    s->mapsp2 = downregion<rpp, rpg>(s->mapsp2);
  }
}

task init_mesh_zones(rz: region<zone>)
  , writes(rz.{zx, zarea, zvol})
{
  for z in rz {
    z->zx = {x: 0.0, y: 0.0};
    z->zarea = 0.0;
    z->zvol = 0.0;
  }
}

// Call calc_centers_full.
// Call calc_volumes_full.

task init_side_fracs(rz: region<zone>, rpp: region<point>, rpg: region<point>,
                     rs: region<side<rz, rpp, rpg, rs>>)
  , reads(rz.zarea, rs.{mapsz, sarea})
  , writes(rs.smf)
{
  for s in rs {
    let z = s->mapsz;

    s->smf = s->sarea / z->zarea;
  }
}

task init_hydro(rz: region<zone>, rinit: double, einit: double,
                rinitsub: double, einitsub: double,
                subregion_x0: double, subregion_x1: double,
                subregion_y0: double, subregion_y1: double)
  , reads(rz.{zx, zvol})
  , writes(rz.{zr, ze, zwrate, zm, zetot})
{
  for z in rz {
    var zr = rinit;
    var ze = einit;

    let eps = 1e-12;
    if (z->zx.x > subregion_x0 - eps &&
        z->zx.x < subregion_x1 + eps &&
        z->zx.y > subregion_y0 - eps &&
        z->zx.y < subregion_y1 + eps) {
      zr = rinitsub;
      ze = einitsub;
    }

    let zm = zr * z->zvol;

    z->zr = zr;
    z->ze = ze;
    z->zwrate = 0.0;
    z->zm = zm;
    z->zetot = ze * zm;
  }
}

task init_radial_velocity(rp: region<point>, vel: double)
  , reads(rp.px)
  , writes(rp.pu)
{
  for p in rp {
    if (vel == 0.0) {
      p->pu = {x: 0.0, y: 0.0};
    } else {
      let pmag = length(p->px);
      p->pu = scale(p->px, vel / pmag);
    }
  }
}

///
/// Main simulation loop
///

// Determine the time step size for this iteration.
task calc_global_dt(dt: double, dtfac: double, dtinit: double, dtmax: double, dthydro: double,
                    time: double, tstop: double, cycle: int)
  : double
{
  let dtlast = dt;

  var dt = dtmax;

  if (cycle == 0) {
    dt = fmin(dt, dtinit);
  } else {
    let dtrecover = dtfac * dtlast;
    dt = fmin(dt, dtrecover);
  }

  dt = fmin(dt, tstop - time);
  dt = fmin(dt, dthydro);

  return dt;
}

// Save off point variable values from previous cycle.
task init_step_points(rp: region<point>)
  , reads(rp.{px, pu})
  , writes(rp.{px0, pu0, pmaswt, pf})
{
  for p in rp {
    // Copy state variables from previous time step.
    p->px0 = p->px;
    p->pu0 = p->pu;

    // Initialize fields used in reductions.
    p->pmaswt = 0.0;
    p->pf = {x: 0.0, y: 0.0};
  }
}

///
/// 1. Advance mesh to center of time step.
///
task adv_pos_half(rp: region<point>, dt: double)
  , reads(rp.{px0, pu0})
  , writes(rp.pxp)
{
  let dth = 0.5 * dt;

  for p in rp {
    p->pxp = add(p->px0, scale(p->pu0, dth));
  }
}

// Save off zone variable value from previous cycle.
task init_step_zones(rz: region<zone>,
                     zstart: int, zend: int, use_foreign: bool)
  , reads(rz.zvol)
  , writes(rz.{zxp, zx, zareap, zarea, zvol0, zvolp, zvol, zdl, zw, zuc})
{
  if (use_foreign) {
    foreign_init_step_zones(zstart, zend, rz);
  } else {
    for z in rz {
      // Copy state variables from previous time step.
      z->zvol0 = z->zvol;

      // Initialize fields used in reductions.
      z->zxp = {x: 0.0, y: 0.0};
      z->zx = {x: 0.0, y: 0.0};
      z->zareap = 0.0;
      z->zarea = 0.0;
      z->zvolp = 0.0;
      z->zvol = 0.0;
      z->zdl = 1e99;
      z->zw = 0.0;
      z->zuc = {x: 0.0, y: 0.0};
    }
  }
}

///
/// 1a. Compute new mesh geometry.
///

// Compute centers of zones and edges.
task calc_centers(rz: region<zone>, rpp: region<point>, rpg: region<point>,
                  rs: region<side<rz, rpp, rpg, rs>>,
                  sstart: int, send: int, use_foreign: bool)
  , reads(rz.{znump, zxp}, rpp.pxp, rpg.pxp, rs.{mapsz, mapsp1, mapsp2})
  , writes(rz.zxp, rs.exp)
{
  if (use_foreign) {
    foreign_calc_centers(sstart, send, rz, rpp, rpg, rs);
  } else {
    for s in rs {
      let z = s->mapsz;
      let p1 = s->mapsp1;
      let p2 = s->mapsp2;
      let e = s;

      e->exp = scale(add(p1->pxp, p2->pxp), 0.5);

      z->zxp.x += p1->pxp.x / double(z->znump);
      z->zxp.y += p1->pxp.y / double(z->znump);
    }
  }
}

// Compute volumes of zones and sides.
task calc_volumes(rz: region<zone>, rpp: region<point>, rpg: region<point>,
                  rs: region<side<rz, rpp, rpg, rs>>,
                  sstart: int, send: int, use_foreign: bool)
  , reads(rz.{zxp, zareap, zvolp}, rpp.pxp, rpg.pxp, rs.{mapsz, mapsp1, mapsp2})
  , writes(rz.{zareap, zvolp}, rs.{sareap, svolp})
{
  if (use_foreign) {
    foreign_calc_volumes(sstart, send, rz, rpp, rpg, rs);
  } else {
    for s in rs {
      let z = s->mapsz;
      let p1 = s->mapsp1;
      let p2 = s->mapsp2;

      let sa = 0.5 * cross(sub(p2->pxp, p1->pxp), sub(z->zxp, p1->pxp));
      let sv = (1.0 / 3.0) * sa * (p1->pxp.x + p2->pxp.x + z->zxp.x);
      s->sareap = sa;
      s->svolp = sv;

      z->zareap += sa;
      z->zvolp += sv;

      assert sv > 0.0;
    }
  }
}

// Compute surface vectors of sides.
task calc_surface_vecs(rz: region<zone>, rpp: region<point>, rpg: region<point>,
                       rs: region<side<rz, rpp, rpg, rs>>,
                       sstart: int, send: int, use_foreign: bool)
  , reads(rz.zxp, rs.{mapsz, exp})
  , writes(rs.ssurfp)
{
  if (use_foreign) {
    foreign_calc_surface_vecs(sstart, send, rz, rs);
  } else {
    for s in rs {
      let z = s->mapsz;
      let e = s;

      s->ssurfp = rotateCCW(sub(e->exp, z->zxp));
    }
  }
}

// Compute edge lengths.
task calc_edge_len(rz: region<zone>, rpp: region<point>, rpg: region<point>,
                   rs: region<side<rz, rpp, rpg, rs>>,
                   sstart: int, send: int, use_foreign: bool)
  , reads(rpp.pxp, rpg.pxp, rs.{mapsp1, mapsp2})
  , writes(rs.elen)
{
  if (use_foreign) {
    foreign_calc_edge_len(sstart, send, rpp, rpg, rs);
  } else {
    for s in rs {
      let p1 = s->mapsp1;
      let p2 = s->mapsp2;
      let e = s;

      e->elen = length(sub(p2->pxp, p1->pxp));
    }
  }
}

// Compute zone characteristic lengths.
task calc_char_len(rz: region<zone>, rpp: region<point>, rpg: region<point>,
                   rs: region<side<rz, rpp, rpg, rs>>,
                   sstart: int, send: int, use_foreign: bool)
  , reads(rz.{znump, zdl}, rs.{mapsz, sareap, elen})
  , writes(rz.zdl)
{
  if (use_foreign) {
    foreign_calc_char_len(sstart, send, rz, rs);
  } else {
    for s in rs {
      let z = s->mapsz;
      let e = s;

      let area = s->sareap;
      let base = e->elen;
      var fac = 0.0;
      if (z->znump == 3) {
        fac = 3.0;
      } else {
        fac = 4.0;
      }
      let sdl = fac * area / base;
      z->zdl = fmin(z->zdl, sdl);
    }
  }
}

///
/// 2. Compute point masses.
///

// Compute zone densities.
task calc_rho_half(rz: region<zone>,
                   zstart: int, zend: int, use_foreign: bool)
  , reads(rz.{zvolp, zm})
  , writes(rz.zrp)
{
  if (use_foreign) {
    foreign_calc_rho_half(zstart, zend, rz);
  } else {
    for z in rz {
      z->zrp = z->zm / z->zvolp;
    }
  }
}

// Reduce masses into points.
task sum_point_mass(rz: region<zone>, rpp: region<point>, rpg: region<point>,
                    rs: region<side<rz, rpp, rpg, rs>>,
                    sstart: int, send: int, use_foreign: bool)
  , reads(rz.{zareap, zrp}, rpp.pmaswt, rs.{mapsz, mapsp1, mapss3, smf})
  , writes(rpp.pmaswt)
  , reduces<+>(rpg.pmaswt)
{
  if (use_foreign) {
    foreign_sum_point_mass(sstart, send, rz, rpp, rpg, rs);
  } else {
    for s in rs {
      let z = s->mapsz;
      let p1 = s->mapsp1;
      let s3 = s->mapss3;

      let m = z->zrp * z->zareap * 0.5 * (s->smf + s3->smf);
      p1->pmaswt += m;
    }
  }
}

///
/// 3. Compute material state (half-advanced).
///


task calc_state_at_half(rz: region<zone>,
                        gamma: double, ssmin: double, dt: double,
                        zstart: int, zend: int, use_foreign: bool)
  , reads(rz.{zvol0, zvolp, zm, zr, ze, zwrate})
  , writes(rz.{zp, zss})
{
  if (use_foreign) {
    foreign_calc_state_at_half(gamma, ssmin, dt, zstart, zend, rz);
  } else {
    let gm1 = gamma - 1.0;
    let ss2 = fmax(ssmin * ssmin, 1e-99);
    let dth = 0.5 * dt;

    for z in rz {
      let rx = z->zr;
      let ex = fmax(z->ze, 0.0);
      let px = gm1 * rx * ex;
      let prex = gm1 * ex;
      let perx = gm1 * rx;
      let csqd = fmax(ss2, prex + perx * px / (rx * rx));
      let z0per = perx;
      let zss = sqrt(csqd);
      z->zss = zss;

      let zminv = 1.0 / z->zm;
      let dv = (z->zvolp - z->zvol0) * zminv;
      let bulk = z->zr * zss * zss;
      let denom = 1.0 + 0.5 * z0per * dv;
      let src = z->zwrate * dth * zminv;
      z->zp = px + (z0per * src - z->zr * bulk * dv) / denom;
    }
  }
}

///
/// 4. Compute forces.
///

// Compute PolyGas forces.
task calc_force_pgas(rz: region<zone>, rpp: region<point>, rpg: region<point>,
                     rs: region<side<rz, rpp, rpg, rs>>,
                     sstart: int, send: int, use_foreign: bool)
  , reads(rz.zp, rs.{mapsz, ssurfp})
  , writes(rs.sfp)
{
  if (use_foreign) {
    foreign_calc_force_pgas(sstart, send, rz, rs);
  } else {
    for s in rs {
      let z = s->mapsz;
      let sfx = scale(s->ssurfp, -z->zp);
      s->sfp = sfx;
    }
  }
}

// Compute TTS forces.
task calc_force_tts(rz: region<zone>, rpp: region<point>, rpg: region<point>,
                    rs: region<side<rz, rpp, rpg, rs>>,
                    alfa: double, ssmin: double,
                    sstart: int, send: int, use_foreign: bool)
  , reads(rz.{zareap, zrp, zss}, rs.{mapsz, sareap, smf, ssurfp})
  , writes(rs.sft)
{
  if (use_foreign) {
    foreign_calc_force_tts(alfa, ssmin, sstart, send, rz, rs);
  } else {
    for s in rs {
      let z = s->mapsz;

      let svfacinv = z->zareap / s->sareap;
      let srho = z->zrp * s->smf * svfacinv;
      let sstmp = fmax(z->zss, ssmin);
      let sstmp = alfa * sstmp * sstmp;
      let sdp = sstmp * (srho - z->zrp);
      let sqq = scale(s->ssurfp, -sdp);
      s->sft = sqq;
    }
  }
}

task qcs_zone_center_velocity(rz: region<zone>, rpp: region<point>, rpg: region<point>,
                              rs: region<side<rz, rpp, rpg, rs>>,
                              sstart: int, send: int, use_foreign: bool)
  , reads(rz.{znump, zuc}, rpp.pu, rpg.pu, rs.{mapsz, mapsp1})
  , writes(rz.zuc)
{
  if (use_foreign) {
    foreign_qcs_zone_center_velocity(sstart, send, rz, rpp, rpg, rs);
  } else {
    for s in rs {
      let z = s->mapsz;
      let p1 = s->mapsp1;

      let zuc = scale(p1->pu, 1.0 / double(z->znump));
      z->zuc.x += zuc.x;
      z->zuc.y += zuc.y;
    }
  }
}

task qcs_corner_divergence(rz: region<zone>, rpp: region<point>, rpg: region<point>,
                           rs: region<side<rz, rpp, rpg, rs>>,
                           sstart: int, send: int, use_foreign: bool)
  , reads(rz.{zxp, zuc}, rpp.{pxp, pu}, rpg.{pxp, pu},
          rs.{mapsz, mapsp1, mapsp2, mapss3, exp, elen})
  , writes(rs.{carea, ccos, cdiv, cevol, cdu})
{
  if (use_foreign) {
    foreign_qcs_corner_divergence(sstart, send, rz, rpp, rpg, rs);
  } else {
    for s2 in rs {
      let c = s2;
      let s = s2->mapss3;
      let z = s->mapsz;
      let p = s->mapsp2;
      let p1 = s->mapsp1;
      let p2 = s2->mapsp2;
      let e1 = s;
      let e2 = s2;

      // velocities and positions
      // point p
      let up0 = p->pu;
      let xp0 = p->pxp;
      // edge e2
      let up1 = scale(add(p->pu, p2->pu), 0.5);
      let xp1 = e2->exp;
      // zone center z
      let up2 = z->zuc;
      let xp2 = z->zxp;
      // edge e1
      let up3 = scale(add(p1->pu, p->pu), 0.5);
      let xp3 = e1->exp;

      // compute 2d cartesian volume of corner
      let cvolume = 0.5 * cross(sub(xp2, xp0), sub(xp3, xp1));
      c->carea = cvolume;

      // compute cosine angle
      let v1 = sub(xp3, xp0);
      let v2 = sub(xp1, xp0);
      let de1 = e1->elen;
      let de2 = e2->elen;
      let minelen = fmin(de1, de2);
      if (minelen < 1e-12) {
        c->ccos = 0.0;
      } else {
        c->ccos = 4.0 * dot(v1, v2) / (de1 * de2);
      }

      // compute divergence of corner
      let cdiv = (cross(sub(up2, up0), sub(xp3, xp1)) -
                  cross(sub(up3, up1), sub(xp2, xp0))) / (2.0 * cvolume);
      c->cdiv = cdiv;

      // compute evolution factor
      let dxx1 = scale(sub(sub(add(xp1, xp2), xp0), xp3), 0.5);
      let dxx2 = scale(sub(sub(add(xp2, xp3), xp0), xp1), 0.5);
      let dx1 = length(dxx1);
      let dx2 = length(dxx2);

      // average corner-centered velocity
      let duav = scale(add(add(add(up0, up1), up2), up3), 0.25);

      let test1 = fabs(dot(dxx1, duav) * dx2);
      let test2 = fabs(dot(dxx2, duav) * dx1);
      var num = 0.0;
      var den = 0.0;
      if (test1 > test2) {
        num = dx1;
        den = dx2;
      } else {
        num = dx2;
        den = dx1;
      }
      let r = num / den;
      let evol = fmin(sqrt(4.0 * cvolume * r), 2.0 * minelen);

      // compute delta velocity
      let dv1 = length(sub(sub(add(up1, up2), up0), up3));
      let dv2 = length(sub(sub(add(up2, up3), up0), up1));
      let du = fmax(dv1, dv2);

      if (cdiv < 0.0) {
        c->cevol = evol;
        c->cdu = du;
      } else {
        c->cevol = 0.0;
        c->cdu = 0.0;
      }
    }
  }
}

task qcs_qcn_force(rz: region<zone>, rpp: region<point>, rpg: region<point>,
                   rs: region<side<rz, rpp, rpg, rs>>,
                   gamma: double, q1: double, q2: double,
                   sstart: int, send: int, use_foreign: bool)
  , reads(rz.{zrp, zss}, rpp.pu, rpg.pu,
          rs.{mapsz, mapsp1, mapsp2, mapss3, elen, cdiv, cdu, cevol})
  , writes(rs.{cqe1, cqe2})
{
  if (use_foreign) {
    foreign_qcs_qcn_force(gamma, q1, q2, sstart, send, rz, rpp, rpg, rs);
  } else {
    let gammap1 = gamma + 1.0;

    for s4 in rs {
      let c = s4;
      let z = c->mapsz;

      let ztmp2 = q2 * 0.25 * gammap1 * c->cdu;
      let ztmp1 = q1 * z->zss;
      let zkur = ztmp2 + sqrt(ztmp2 * ztmp2 + ztmp1 * ztmp1);
      var rmu = zkur * z->zrp * c->cevol;
      if (c->cdiv > 0.0) {
        rmu = 0.0;
      }

      let s = c->mapss3;
      let p = s->mapsp2;
      let p1 = s->mapsp1;
      let e1 = s;
      let p2 = s4->mapsp2;
      let e2 = s4;

      c->cqe1 = scale(sub(p->pu, p1->pu), rmu / e1->elen);
      c->cqe2 = scale(sub(p2->pu, p->pu), rmu / e2->elen);
    }
  }
}

task qcs_force(rz: region<zone>, rpp: region<point>, rpg: region<point>,
               rs: region<side<rz, rpp, rpg, rs>>,
               sstart: int, send: int, use_foreign: bool)
  , reads(rs.{mapss4, elen, carea, ccos, cqe1, cqe2})
  , writes(rs.sfq)
{
  if (use_foreign) {
    foreign_qcs_force(sstart, send, rs);
  } else {
    for s in rs {
      let c1 = s;
      let c2 = s->mapss4;
      let e = s;
      let el = e->elen;

      let c1sin2 = 1.0 - c1->ccos * c1->ccos;
      var c1w = 0.0;
      var c1cos = 0.0;
      if (c1sin2 >= 1e-4) {
        c1w = c1->carea / c1sin2;
        c1cos = c1->ccos;
      }

      let c2sin2 = 1.0 - c2->ccos * c2->ccos;
      var c2w = 0.0;
      var c2cos = 0.0;
      if (c2sin2 >= 1e-4) {
        c2w = c2->carea / c2sin2;
        c2cos = c2->ccos;
      }

      s->sfq = scale(add(scale(add(c1->cqe2, scale(c1->cqe1, c1cos)), c1w),
                         scale(add(c2->cqe1, scale(c2->cqe2, c2cos)), c2w)),
                     1.0 / el);
    }
  }
}

// Compute QCS forces.
task calc_force_qcs(rz: region<zone>, rpp: region<point>, rpg: region<point>,
                    rs: region<side<rz, rpp, rpg, rs>>,
                    gamma: double, q1: double, q2: double,
                    sstart: int, send: int, use_foreign: bool)
  , reads(rz.{zxp, zrp, znump, zss, zuc}, rpp.{pxp, pu}, rpg.{pxp, pu},
          rs.{mapsz, mapsp1, mapsp2, mapss3, mapss4, exp, elen, carea, ccos, cevol, cdiv, cdu, cqe1, cqe2})
  , writes(rz.zuc, rs.{sfq, carea, cdiv, cevol, ccos, cdu, cqe1, cqe2})
{
  qcs_zone_center_velocity(rz, rpp, rpg, rs, sstart, send, use_foreign);
  qcs_corner_divergence(rz, rpp, rpg, rs, sstart, send, use_foreign);
  qcs_qcn_force(rz, rpp, rpg, rs, gamma, q1, q2, sstart, send, use_foreign);
  qcs_force(rz, rpp, rpg, rs, sstart, send, use_foreign);
}

// Reduce forces into points.
task sum_point_force(rz: region<zone>, rpp: region<point>, rpg: region<point>,
                     rs: region<side<rz, rpp, rpg, rs>>,
                     sstart: int, send: int, use_foreign: bool)
  , reads(rpp.pf, rs.{mapsz, mapsp1, mapss3, sfp, sfq, sft})
  , writes(rpp.pf)
  , reduces<+>(rpg.pf.{x, y})
{
  if (use_foreign) {
    foreign_sum_point_force(sstart, send, rpp, rpg, rs);
  } else {
    for s in rs {
      let z = s->mapsz;
      let p1 = s->mapsp1;
      let s3 = s->mapss3;

      let f = sub(add(s->sfp, add(s->sfq, s->sft)),
                  add(s3->sfp, add(s3->sfq, s3->sft)));
      p1->pf.x += f.x;
      p1->pf.y += f.y;
    }
  }
}

///
/// 4a. Apply boundary conditions.
///

task apply_boundary_conditions(rp: region<point>)
  , reads(rp.{pu0, pf, has_bcx_0, has_bcx_1, has_bcy_0, has_bcy_1})
  , writes(rp.{pu0, pf})
{
  let vfixx = {x: 1.0, y: 0.0};
  let vfixy = {x: 0.0, y: 1.0};
  for p in rp {
    if (p->has_bcx_0 || p->has_bcx_1) {
      p->pu0 = project(p->pu0, vfixx);
      p->pf = project(p->pf, vfixx);
    }
    if (p->has_bcy_0 || p->has_bcy_1) {
      p->pu0 = project(p->pu0, vfixy);
      p->pf = project(p->pf, vfixy);
    }
  }
}

///
/// 5. Compute accelerations.
///

task calc_accel(rp: region<point>)
  , reads(rp.{pf, pmaswt})
  , writes(rp.pap)
{
  let fuzz = 1e-99;
  for p in rp {
    p->pap = scale(p->pf, 1.0 / fmax(p->pmaswt, fuzz));
  }
}

///
/// 6. Advance mesh to end of time step.
///

task adv_pos_full(rp: region<point>, dt: double)
  , reads(rp.{px0, pu0, pap})
  , writes(rp.{px, pu})
{
  for p in rp {
    let pu = add(p->pu0, scale(p->pap, dt));
    p->pu = pu;
    p->px = add(p->px0, scale(add(pu, p->pu0), 0.5 * dt));
  }
}

///
/// 6a. Compute new mesh geometry.
///

// FIXME: This is a duplicate of calc_centers but with different
// code. Struct slicing ought to make it possible to use the same code
// in both cases.
task calc_centers_full(rz: region<zone>, rpp: region<point>, rpg: region<point>,
                       rs: region<side<rz, rpp, rpg, rs>>,
                       sstart: int, send: int, use_foreign: bool)
  , reads(rz.{znump, zx}, rpp.px, rpg.px, rs.{mapsz, mapsp1, mapsp2})
  , writes(rz.zx, rs.ex)
{
  if (use_foreign) {
    foreign_calc_centers_full(sstart, send, rz, rpp, rpg, rs);
  } else {
    for s in rs {
      let z = s->mapsz;
      let p1 = s->mapsp1;
      let p2 = s->mapsp2;
      let e = s;

      e->ex = scale(add(p1->px, p2->px), 0.5);

      z->zx.x += p1->px.x / double(z->znump);
      z->zx.y += p1->px.y / double(z->znump);
    }
  }
}

// FIXME: This is a duplicate of calc_volumes but with different
// code. Struct slicing ought to make it possible to use the same code
// in both cases.
task calc_volumes_full(rz: region<zone>, rpp: region<point>, rpg: region<point>,
                       rs: region<side<rz, rpp, rpg, rs>>,
                       sstart: int, send: int, use_foreign: bool)
  , reads(rz.{zx, zarea, zvol}, rpp.px, rpg.px, rs.{mapsz, mapsp1, mapsp2})
  , writes(rz.{zarea, zvol}, rs.{sarea, svol})
{
  if (use_foreign) {
    foreign_calc_volumes_full(sstart, send, rz, rpp, rpg, rs);
  } else {
    for s in rs {
      let z = s->mapsz;
      let p1 = s->mapsp1;
      let p2 = s->mapsp2;

      let sa = 0.5 * cross(sub(p2->px, p1->px), sub(z->zx, p1->px));
      let sv = (1.0 / 3.0) * sa * (p1->px.x + p2->px.x + z->zx.x);
      s->sarea = sa;
      s->svol = sv;

      z->zarea += sa;
      z->zvol += sv;

      assert sv > 0.0;
    }
  }
}

///
/// 7. Compute work
///

task calc_work(rz: region<zone>, rpp: region<point>, rpg: region<point>,
               rs: region<side<rz, rpp, rpg, rs>>,
               dt: double,
               sstart: int, send: int, use_foreign: bool)
  , reads(rz.{zw, zetot}, rpp.{pxp, pu0, pu}, rpg.{pxp, pu0, pu},
          rs.{mapsz, mapsp1, mapsp2, sfp, sfq})
  , writes(rz.{zw, zetot})
{
  if (use_foreign) {
    foreign_calc_work(dt, sstart, send, rz, rpp, rpg, rs);
  } else {
    for s in rs {
      let z = s->mapsz;
      let p1 = s->mapsp1;
      let p2 = s->mapsp2;

      let sftot = add(s->sfp, s->sfq);
      let sd1 = dot(sftot, add(p1->pu0, p1->pu));
      let sd2 = dot(scale(sftot, -1.0), add(p2->pu0, p2->pu));
      let dwork = -0.5 * dt * (sd1 * p1->pxp.x + sd2 * p2->pxp.x);

      z->zetot += dwork;
      z->zw += dwork;
    }
  }
}

///
/// 7a. Compute work rate.
///

task calc_work_rate(rz: region<zone>, dt: double)
  , reads(rz.{zvol0, zvol, zw, zp})
  , writes(rz.zwrate)
{
  let dtiny = 1.0 / dt;

  for z in rz {
    let dvol = z->zvol - z->zvol0;
    z->zwrate = (z->zw + z->zp * dvol) * dtiny;
  }
}

///
/// 8. Update state variables.
///

task calc_energy(rz: region<zone>)
  , reads(rz.{zm, zetot})
  , writes(rz.ze)
{
  let fuzz = 1e-99;

  for z in rz {
    z->ze = z->zetot / (z->zm + fuzz);
  }
}

task calc_rho_full(rz: region<zone>)
  , reads(rz.{zvol, zm})
  , writes(rz.zr)
{
  for z in rz {
    z->zr = z->zm / z->zvol;
  }
}

///
/// 9. Compute timstep for next cycle.
///

task calc_dt_courant(rz: region<zone>, dtmax: double, cfl: double)
  : double
  , reads(rz.{zdl, zss})
{
  let fuzz = 1e-99;
  var dtnew = dtmax;
  for z in rz {
    let cdu = fmax(z->zss, fuzz);
    let zdthyd = z->zdl * cfl / cdu;

    dtnew = fmin(dtnew, zdthyd);
  }

  return dtnew;
}

task calc_dt_volume(rz: region<zone>, dtlast: double, cflv: double)
  : double
  , reads(rz.{zvol0, zvol})
{
  var dvovmax = 1e-99;
  for z in rz {
    let zdvov = fabs((z->zvol - z->zvol0) / z->zvol0);
    dvovmax = fmax(zdvov, dvovmax);
  }
  return dtlast * cflv / dvovmax;
}

task calc_dt_hydro(rz: region<zone>, dtlast: double, dtmax: double, cfl: double, cflv: double)
  : double
  , reads(rz.{zdl, zvol0, zvol, zss})
{
  var dthydro = dtmax;

  dthydro = fmin(dthydro,
                 fmin(calc_dt_courant(rz, dtmax, cfl),
                      calc_dt_volume(rz, dtlast, cflv)));

  return dthydro;
}

task initialize(rz_all: region<zone>, rp_all: region<point>,
                rs_all: region<side<?, ?, ?, ?>>,
                rm_all: region<mesh<rz_all, rp_all, rs_all>>,
                conf: config)
  , reads(rz_all, rp_all, rs_all, rm_all)
  , writes(rz_all, rp_all, rs_all, rm_all)
{
  let einit = conf.einit;
  let einitsub = conf.einitsub;
  let rinit = conf.rinit;
  let rinitsub = conf.rinitsub;
  let subregion_0 = conf.subregion_0;
  let subregion_1 = conf.subregion_1;
  let subregion_2 = conf.subregion_2;
  let subregion_3 = conf.subregion_3;
  let uinitradial = conf.uinitradial;

  let use_foreign = conf.use_foreign;

  for m in rm_all {
    unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
    init_pointers(rz, rpp, rpg, rs);
  }

  for m in rm_all {
    unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
    init_mesh_zones(rz);
  }

  for m in rm_all {
    unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
    calc_centers_full(rz, rpp, rpg, rs, n.sstart, n.send, use_foreign);
  }

  for m in rm_all {
    unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
    calc_volumes_full(rz, rpp, rpg, rs, n.sstart, n.send, use_foreign);
  }

  for m in rm_all {
    unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
    init_side_fracs(rz, rpp, rpg, rs);
  }

  for m in rm_all {
    unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
    init_hydro(rz, rinit, einit, rinitsub, einitsub, subregion_0, subregion_1, subregion_2, subregion_3);
  }

  for m in rm_all {
    unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
    init_radial_velocity(rpp, uinitradial);
    init_radial_velocity(rps, uinitradial);
  }
}

task simulate(rz_all: region<zone>, rp_all: region<point>,
              rs_all: region<side<?, ?, ?, ?>>,
              rm_all: region<mesh<rz_all, rp_all, rs_all>>,
              conf: config)
  , reads(rz_all, rp_all, rs_all, rm_all)
  , writes(rz_all, rp_all, rs_all, rm_all)
{
  let alfa = conf.alfa;
  let cfl = conf.cfl;
  let cflv = conf.cflv;
  let cstop = conf.cstop;
  let dtfac = conf.dtfac;
  let dtinit = conf.dtinit;
  let dtmax = conf.dtmax;
  let gamma = conf.qgamma;
  let q1 = conf.q1;
  let q2 = conf.q2;
  let qgamma = conf.qgamma;
  let ssmin = conf.ssmin;
  let tstop = conf.tstop;
  let uinitradial = conf.uinitradial;
  let vfix = {x: 0.0, y: 0.0};

  let use_foreign = conf.use_foreign;

  let interval = 10;
  let start_time = get_abs_time();
  var last_time = start_time;

  var time = 0.0;
  var cycle = 0;
  var dt = dtmax;
  var dthydro = dtmax;
  while (cycle < cstop && time < tstop) {
    dt = calc_global_dt(dt, dtfac, dtinit, dtmax, dthydro, time, tstop, cycle);

    if (cycle > 0 && cycle % interval == 0) {
      let current_time = get_abs_time();
      print_simulation_loop(cycle, time, dt, start_time, last_time, current_time, interval);
      last_time = current_time;
    }

    for m in rm_all {
      unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
      init_step_points(rpp);
      init_step_points(rps);
    }

    for m in rm_all {
      unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
      adv_pos_half(rpp, dt);
      adv_pos_half(rps, dt);
    }

    for m in rm_all {
      unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
      init_step_zones(rz, n.zstart, n.zend, use_foreign);
    }

    for m in rm_all {
      unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
      calc_centers(rz, rpp, rpg, rs, n.sstart, n.send, use_foreign);
    }

    for m in rm_all {
      unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
      calc_volumes(rz, rpp, rpg, rs, n.sstart, n.send, use_foreign);
    }

    for m in rm_all {
      unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
      calc_surface_vecs(rz, rpp, rpg, rs, n.sstart, n.send, use_foreign);
    }

    for m in rm_all {
      unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
      calc_edge_len(rz, rpp, rpg, rs, n.sstart, n.send, use_foreign);
    }

    for m in rm_all {
      unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
      calc_char_len(rz, rpp, rpg, rs, n.sstart, n.send, use_foreign);
    }

    for m in rm_all {
      unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
      calc_rho_half(rz, n.zstart, n.zend, use_foreign);
    }

    for m in rm_all {
      unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
      sum_point_mass(rz, rpp, rpg, rs, n.sstart, n.send, use_foreign);
    }

    for m in rm_all {
      unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
      calc_state_at_half(rz, gamma, ssmin, dt, n.zstart, n.zend, use_foreign);
    }

    for m in rm_all {
      unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
      calc_force_pgas(rz, rpp, rpg, rs, n.sstart, n.send, use_foreign);
    }

    for m in rm_all {
      unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
      calc_force_tts(rz, rpp, rpg, rs, alfa, ssmin, n.sstart, n.send, use_foreign);
    }

    for m in rm_all {
      unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
      calc_force_qcs(rz, rpp, rpg, rs, qgamma, q1, q2, n.sstart, n.send, use_foreign);
    }

    for m in rm_all {
      unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
      sum_point_force(rz, rpp, rpg, rs, n.sstart, n.send, use_foreign);
    }

    for m in rm_all {
      unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
      apply_boundary_conditions(rpp);
      apply_boundary_conditions(rps);
    }

    for m in rm_all {
      unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
      calc_accel(rpp);
      calc_accel(rps);
    }

    for m in rm_all {
      unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
      adv_pos_full(rpp, dt);
      adv_pos_full(rps, dt);
    }

    for m in rm_all {
      unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
      calc_centers_full(rz, rpp, rpg, rs, n.sstart, n.send, use_foreign);
    }

    for m in rm_all {
      unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
      calc_volumes_full(rz, rpp, rpg, rs, n.sstart, n.send, use_foreign);
    }

    for m in rm_all {
      unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
      calc_work(rz, rpp, rpg, rs, dt, n.sstart, n.send, use_foreign);
    }

    for m in rm_all {
      unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
      calc_work_rate(rz, dt);
    }

    for m in rm_all {
      unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
      calc_energy(rz);
    }

    for m in rm_all {
      unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
      calc_rho_full(rz);
    }

    dthydro = dtmax;
    for m in rm_all {
      unpack *m as n: mesh<rz_all, rp_all, rs_all>[rz, rpp, rpg, rps, rs];
      dthydro = fmin(dthydro, calc_dt_hydro(rz, dt, dtmax, cfl, cflv));
    }

    cycle += 1;
    time += dt;
  }
}

task all_zones_coloring(rz_all: region<zone>, rp_all: region<point>,
                        rs_all: region<side<?, ?, ?, ?>>,
                        rm_all: region<mesh<rz_all, rp_all, rs_all>>,
                        conf: config)
  : coloring<rz_all>
  , reads(rm_all.{zstart, zend})
{
  return foreign_all_zones_coloring(conf, rm_all);
}

task all_points_coloring(rp_all: region<point>,
                         pcolor_is: ispace<int>, pcolor_a: array<pcolor_is, int>,
                         conf: config)
  : coloring<rp_all>
  , reads(pcolor_a)
{
  return foreign_all_points_coloring(conf, pcolor_a);
}

task private_points_coloring(rp_all_private: region<point>,
                             pcolor_is: ispace<int>, pcolor_a: array<pcolor_is, int>,
                             conf: config)
  : coloring<rp_all_private>
  , reads(pcolor_a)
{
  return foreign_private_points_coloring(conf, pcolor_a);
}

task ghost_points_coloring(rp_all_ghost: region<point>,
                           pcolor_is: ispace<int>, pcolor_a: array<pcolor_is, int>,
                           pcolors_is: ispace<int>, pcolors_a: array<pcolors_is, uint64>,
                           conf: config)
  : coloring<rp_all_ghost>
  , reads(pcolor_a, pcolors_a)
{
  return foreign_ghost_points_coloring(conf, pcolor_a, pcolors_a);
}

task shared_points_coloring(rp_all_shared: region<point>,
                            pcolor_shared_is: ispace<int>, pcolor_shared_a: array<pcolor_shared_is, int>,
                            conf: config)
  : coloring<rp_all_shared>
  , reads(pcolor_shared_a)
{
  return foreign_shared_points_coloring(conf, pcolor_shared_a);
}

task all_sides_coloring(rz_all: region<zone>, rp_all: region<point>,
                        rs_all: region<side<?, ?, ?, ?>>,
                        rm_all: region<mesh<rz_all, rp_all, rs_all>>,
                        conf: config)
  : coloring<rs_all>
  , reads(rm_all.{sstart, send})
{
  return foreign_all_sides_coloring(conf, rm_all);
}

task read_input(conf: config,
                rz_all: region<zone>, rp_all: region<point>, rs_all: region<side<?, ?, ?, ?>>,
                rm_all: region<mesh<rz_all, rp_all, rs_all>>,
                pcolor_is: ispace<int>, pcolor_a: array<pcolor_is, int>,
                pcolors_is: ispace<int>, pcolors_a: array<pcolors_is, uint64>,
                pcolor_shared_is: ispace<int>, pcolor_shared_a: array<pcolor_shared_is, int>)
  , reads(rz_all, rp_all, rs_all, rm_all, pcolor_a, pcolors_a, pcolor_shared_a)
  , writes(rz_all, rp_all, rs_all, rm_all, pcolor_a, pcolors_a, pcolor_shared_a)
{
  foreign_read_input(conf, rz_all, rp_all, rs_all, rm_all, pcolor_a, pcolors_a, pcolor_shared_a);
}

task validate_output(conf: config,
                     rz_all: region<zone>, rp_all: region<point>, rs_all: region<side<?, ?, ?, ?>>)
  , reads(rz_all, rp_all, rs_all)
{
  foreign_validate_output(conf, rz_all, rp_all, rs_all);
}

task test()
{
  let conf = read_config();

  let rz_all = region<zone>(conf.nz);
  let rp_all = region<point>(conf.np);
  let rs_all = region<side<?, ?, ?, ?>>(conf.ns);
  let rm_all = region<mesh<rz_all, rp_all, rs_all>>(conf.npieces);

  // Create temporary arrays for pointers to use while building the
  // regions.

  // Array for tracking number of colors per point:
  let pcolor_is = ispace<int>(conf.np);
  let pcolor_a = array<pcolor_is, int>();

  // Bitmask for colors of ghost points:
  let bits = 64;                                // must match bitmask type
  let words = (conf.npieces + bits - 1)/bits;
  let pcolors_is = ispace<int>(conf.np*words);
  let pcolors_a = array<pcolors_is, uint64>();   // must match bits

  // Array for colors of disjoint partition of shared points:
  let pcolor_shared_is = ispace<int>(conf.np);
  let pcolor_shared_a = array<pcolor_shared_is, int>();

  // Read simulation data into regions.
  read_input(conf, rz_all, rp_all, rs_all, rm_all, pcolor_is, pcolor_a, pcolors_is, pcolors_a, pcolor_shared_is, pcolor_shared_a);

  // Partition zones into disjoint pieces.
  let rz_all_c = all_zones_coloring(rz_all, rp_all, rs_all, rm_all, conf);
  let rz_all_p = partition<rz_all, disjoint>(rz_all_c);

  // Partition points into private and ghost regions.
  let rp_all_c = all_points_coloring(rp_all, pcolor_is, pcolor_a, conf);
  let rp_all_p = partition<rp_all, disjoint>(rp_all_c);
  let rp_all_private = rp_all_p[0];
  let rp_all_ghost = rp_all_p[1];

  // Partition private points into disjoint pieces by zone.
  let rp_all_private_c = private_points_coloring(rp_all_private, pcolor_is, pcolor_a, conf);
  let rp_all_private_p = partition<rp_all_private, disjoint>(rp_all_private_c);

  // Partition ghost points into aliased pieces by zone.
  let rp_all_ghost_c = ghost_points_coloring(rp_all_ghost, pcolor_is, pcolor_a, pcolors_is, pcolors_a, conf);
  let rp_all_ghost_p = partition<rp_all_ghost, aliased>(rp_all_ghost_c);

  // Partition ghost points into disjoint pieces, breaking ties
  // between zones so that each point goes into one region only.
  let rp_all_shared_c = shared_points_coloring(rp_all_ghost, pcolor_shared_is, pcolor_shared_a, conf);
  let rp_all_shared_p = partition<rp_all_ghost, disjoint>(rp_all_shared_c);

  // Partition sides into disjoint pieces by zone.
  let rs_all_c = all_sides_coloring(rz_all, rp_all, rs_all, rm_all, conf);
  let rs_all_p = partition<rs_all, disjoint>(rs_all_c);

  // Stuff regions into mesh pieces.
  for m in rm_all {
    let zones = rz_all_p[m->mcolor];
    let private = rp_all_private_p[m->mcolor];
    let ghost = rp_all_ghost_p[m->mcolor];
    let shared = rp_all_shared_p[m->mcolor];
    let sides = rs_all_p[m->mcolor];

    *m = pack {mcolor: m->mcolor, zstart: m->zstart, zend: m->zend, sstart: m->sstart, send: m->send}
           as mesh<rz_all, rp_all, rs_all>[zones, private, ghost, shared, sides];
  }

  initialize(rz_all, rp_all, rs_all, rm_all, conf);

  print_simulation_start();
  let start_time = get_abs_time();
  simulate(rz_all, rp_all, rs_all, rm_all, conf);
  let stop_time = get_abs_time();
  print_global_elapsed_time(start_time, stop_time);

  // write_output(conf, rz_all, rp_all, rs_all);
  validate_output(conf, rz_all, rp_all, rs_all);
}

task toplevel()
{
  test();
}
