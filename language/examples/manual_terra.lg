-- Copyright 2015 Stanford University
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

terralib.require('legionlib-terra')
cstdio = terralib.includec('stdio.h')
legion_c = terralib.includec('legion_c.h')

TID_TOP_LEVEL = 100
TID_FIB = 101
TID_SUB = 102

terra fib(x : int) : int
  if x <= 1 then
    return 1
  end
  return fib(x - 1) + fib(x - 2)
end

struct fib_args {
  x : int
}

struct fib_args_full {
  task : &opaque,
  rest : fib_args,
}

terra sub_task(args : &fib_args, task : TTask,
               regions: &TPhysicalRegion, num_regions: uint64,
               ctx: &opaque, runtime: &opaque)
  cstdio.printf("inside sub_task(%d) ctx %p runtime %p\n", args.x, ctx, runtime)
end

terra fib_task(args : &fib_args, task : TTask,
               regions: &TPhysicalRegion, num_regions: uint64,
               ctx: &opaque, runtime: &opaque)
  cstdio.printf("inside fib_task(%d) ctx %p runtime %p\n", args.x, ctx, runtime)
  var y = fib(args.x)
  cstdio.printf("fib(%d) = %d\n", args.x, y)
  -- return y

  var runtime_ = legion_c.legion_runtime_t { impl = runtime }
  var ctx_ = legion_c.legion_context_t { impl = ctx }

  var is = legion_c.legion_index_space_create(runtime_, ctx_, 5)
  var fs = legion_c.legion_field_space_create(runtime_, ctx_)
  var r = legion_c.legion_logical_region_create(runtime_, ctx_, is, fs)
  var isa = legion_c.legion_index_allocator_create(runtime_, ctx_, is)
  var fsa = legion_c.legion_field_allocator_create(runtime_, ctx_, fs)

  cstdio.printf("created region (%d,%d,%d)\n",
                r.tree_id, r.index_space.id, r.field_space.id)

  var ptr1 = legion_c.legion_index_allocator_alloc(isa, 1)
  var ptr2 = legion_c.legion_index_allocator_alloc(isa, 1)

  cstdio.printf("allocated pointers %d %d\n",
                ptr1.value, ptr2.value)

  var f1 = legion_c.legion_field_allocator_allocate_field(fsa, sizeof(int), 1)
  var f2 = legion_c.legion_field_allocator_allocate_field(fsa, sizeof(int), 2)

  cstdio.printf("allocated fields %d %d\n",
                f1, f2)

  var buffer = fib_args_full { task = sub_task, rest = @args }
  var sub_args = legion_c.legion_task_argument_t { args = &buffer, arglen = terralib.sizeof(fib_args_full) }
  var launcher = legion_c.legion_task_launcher_create(
    TID_SUB,
    sub_args,
    legion_c.legion_predicate_true(),
    0, 0)

  var f = legion_c.legion_task_launcher_execute(runtime_, ctx_, launcher)
  legion_c.legion_future_destroy(f)

  legion_c.legion_field_allocator_destroy(fsa)
  legion_c.legion_index_allocator_destroy(isa)
  legion_c.legion_logical_region_destroy(runtime_, ctx_, r)
  legion_c.legion_field_space_destroy(runtime_, ctx_, fs)
  legion_c.legion_index_space_destroy(runtime_, ctx_, is)
end

function top_level_task(binding, regions, args)
  print("top_level_task")

  print("calling fib_task(5)")
  local fib_launcher = TerraTaskLauncher:new(
    TID_FIB, fib_task,
    fib_args, { x = 5 })
  local f = binding:execute_terra_task(fib_launcher)
  local z = f:get_result_int()
  print("returns " .. tostring(z))
end

if rawget(_G, "arg") then
  local binding = LegionLib:init_binding(arg[0])

  binding:set_top_level_task_id(TID_TOP_LEVEL)
  binding:register_single_task(TID_TOP_LEVEL, "top_level_task",
                               Processor.LOC_PROC, false)
  binding:register_terra_task(TID_FIB,
                              Processor.LOC_PROC, true, false)
  binding:register_terra_task(TID_SUB,
                              Processor.LOC_PROC, true, false)
  binding:start(arg)
end
